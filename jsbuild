#!/usr/bin/env python

# Python script to build SpiderMonkey

import os
import os.path
import sys
import shutil
import argparse
import subprocess
import glob

# --with-system-nspr doesn't work with crosscompilation, because it
# tries to link with the host library

build_options = {
    'common':  '--with-ccache=`which ccache`',
    'threads': '--with-system-nspr --enable-threadsafe',
    'ctypes':  '--enable-ctypes --with-system-nspr --enable-threadsafe',
    'debug':   '--enable-debug --disable-optimize --enable-gczeal',
    'rooting': '--enable-root-analysis --disable-threadsafe',
    'exact':   '--enable-exact-rooting --disable-threadsafe',
    'ggc':     '--enable-gcgenerational --enable-exact-rooting --disable-threadsafe',
    'arm':     '--with-arch=armv7-a --with-thumb --disable-intl-api'
}

build_configs = {
    'opt':       ['common'],
    'nothreads': ['common', 'debug'],
    'debug':     ['common', 'debug', 'threads'],
    'rooting':   ['common', 'debug', 'rooting'],
    'exact':     ['common', 'debug', 'exact'],
    'ggc':       ['common', 'debug', 'ggc']
}
build_names = build_configs.keys()

compilers = {
    'clang': (None, 'clang', 'clang++'),
    'gcc':   (None, 'gcc', 'g++'),
    'armsf': ('arm-linux-gnueabi', 'arm-linux-gnueabi-gcc', 'arm-linux-gnueabi-g++'),
    'armhf': ('arm-linux-gnueabihf', 'arm-linux-gnueabihf-gcc', 'arm-linux-gnueabihf-g++')
}
compiler_names = compilers.keys()

parser = argparse.ArgumentParser(description = 'Build SpiderMonkey')
parser.add_argument('-c', '--clean', action='store_true', help = 'Clean build')
parser.add_argument('-C', '--no-clean', action='store_false', dest = 'clean')
parser.add_argument('-w', '--warnings', action='store_true', help = 'Show warnings')
parser.add_argument('-v', '--verbose', action='store_true', help = 'Show all build output')
parser.add_argument('build', nargs ='?', choices = build_names, default = 'debug', 
                    help = 'Build config to use')
parser.add_argument('compiler', nargs ='?', choices = compiler_names, default = None, 
                    help = 'Compiler to use')
args = parser.parse_args()

def which(name):
    try:
        return subprocess.check_output('which ' + name, shell = True).splitlines()[0]
    except subprocess.CalledProcessError:
        return None

def run_command(command):
    if args.verbose:
        print(command)
    proc = subprocess.Popen(command, stdout = subprocess.PIPE, stderr = subprocess.STDOUT, 
                            shell = True)
    while proc.poll() == None:
        line = proc.stdout.readline()
        if not line:
            break
        if args.verbose or "error:" in line or (args.warnings and "warning:" in line):
            print(line.rstrip())
    if proc.returncode:
        sys.exit('Command failed with returncode ' + str(proc.returncode))

if not os.path.isfile("jsapi.h"):
    sys.exit('Run jsbuild from the js/src directory')

if os.path.getmtime('configure.in') > os.path.getmtime('configure'):
    print('Autoconf')
    autoconf = which('autoconf213') or which('autoconf2.13')
    if not autoconf:
        sys.exit('Can\'t find autoconf 2.13')
    subprocess.check_call(autoconf)

    print('Clean all')
    args.clean = False
    for build in glob.glob('*-build'):
        if os.path.isdir(build):
            shutil.rmtree(build)

name = args.build

if args.compiler:
    name += '-' + args.compiler
    target = compilers[args.compiler][0]
    cc = which(compilers[args.compiler][1])
    cxx = which(compilers[args.compiler][2])
    if not cc or not cxx:
        sys.exit("Compiler for %s build not found on path" % args.compiler)
    if not target:
        os.environ['CC'] = cc
        os.environ['CXX'] = cxx
else:
    # Clang is preferred for rooting builds (it shows up more problems), and it is
    # faster in general, so use it if possible
    target = None
    clang_cc = which('clang')
    clang_cxx = which('clang++')
    if clang_cc and clang_cxx:
        os.environ['CC'] = clang_cc
        os.environ['CXX'] = clang_cxx

dir = name + '-build'

if args.clean:
    print('Clean ' + name)
    if os.path.isdir(dir):
        shutil.rmtree(dir)

if not os.path.isdir(dir):
    print('Configure ' + name)
    os.mkdir(dir)
    os.chdir(dir)

    config = ' '.join([build_options[opt] for opt in build_configs[args.build]])
    if target:
        config += ' --target=' + target
    if args.compiler and args.compiler.startswith('arm'):
        config += ' ' + build_options['arm']
        
    run_command('../configure ' + config)
    os.chdir('..')

print('Build ' + name)
try:
    nproc = int(subprocess.check_output('nproc').splitlines()[0])
except subprocess.CalledProcessError:
    nproc = 8
run_command('nice make -C %s -j%d' % (dir, nproc))
