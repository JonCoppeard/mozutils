#!/usr/bin/env python3

# Run benchmarks for two builds and compare interactively.

import argparse
import math
import os
import os.path
import re
import signal
import subprocess
import sys

sys.path.append(os.path.join(os.path.dirname(__file__), '..', 'lib'))

from display import *;
from stats import *;

def main():
    args = parseArgs()

    builds = list(map(Build, args.builds))

    iterations = 20

    tests = [
        OctaneTest('richards'),
        OctaneTest('deltablue'),
        OctaneTest('crypto'),
        OctaneTest('raytrace'),
        OctaneTest('earley-boyer'),
        OctaneTest('regexp'),
        OctaneTest('splay'),
        OctaneTest('navier-stokes'),
        OctaneTest('pdfjs'),
        OctaneTest('mandreel'),
        OctaneTest('gbemu'),
        OctaneTest('code-load'),
        OctaneTest('box2d'),
        OctaneTest('zlib'),
        OctaneTest('typescript')
    ]

    if args.test:
        tests = list(filter(lambda t: t.name == args.test, tests))
        if not tests:
            sys.exit(f"Test '{args.test}' not found")

    scores = []

    results = dict()

    printHeader()
    displayResults(builds, scores, results, args.show_samples)

    for i in range(iterations):
        for build in builds:
            for test in tests:
                result = runBenchmark(build, test)
                for score in result.keys():
                    if score not in results:
                        addScore(builds, scores, results, score)
                    results[score][build].append(result[score])
                with DelayedKeyboardInterrupt():
                    displayResults(builds, scores, results, args.show_samples)

class Build:
    def __init__(self, spec):
        command = spec.split()
        path = command[0]
        shell = os.path.join(path, "shell")
        ensure(canExecute(shell), f"Executeable shell not found at: {shell}")
        self.spec = spec
        self.path = os.path.normpath(path)
        self.name = os.path.basename(self.path)
        self.shell = os.path.abspath(shell)
        self.args = command[1:]

    def __repr__(self):
        return f"Build({self.name})"

class Test:
    def __init__(self, name, dir, script):
        self.name = name
        self.dir = dir
        self.script = script

class OctaneTest(Test):
    def __init__(self, name):
        super().__init__(name, 'octane', f"run-{name}.js")

class DelayedKeyboardInterrupt(object):
    # From https://stackoverflow.com/a/21919644
    def __enter__(self):
        self.signal_received = False
        self.old_handler = signal.signal(signal.SIGINT, self.handler)

    def handler(self, sig, frame):
        self.signal_received = (sig, frame)

    def __exit__(self, type, value, traceback):
        signal.signal(signal.SIGINT, self.old_handler)
        if self.signal_received:
            self.old_handler(*self.signal_received)

def ensure(condition, error):
    if not condition:
        sys.exit(error)

def canExecute(path):
    return os.path.isfile(path) and os.access(path, os.X_OK)

def parseArgs():
    parser = argparse.ArgumentParser(description = 'Benchmark SpiderMonkey')
    parser.add_argument('-t', '--test', help='Test suite to run')
    parser.add_argument('--show-samples', action='store_true')
    parser.add_argument('builds', nargs="+")
    return parser.parse_args()

def runBenchmark(build, test):
    oldcwd = os.getcwd()
    os.chdir(test.dir)
    cmd = [build.shell] + build.args + [test.script]
    env = dict()
    env['JSGC_DISABLE_POISONING'] = '1'
    proc = subprocess.run(cmd, env=env, capture_output=True, text=True)
    if proc.returncode != 0:
        print(f"Error running benchmark {test.name} with shell {build.shell}:")
        print(' '.join(cmd))
        print(proc.stderr)
        sys.exit(1)
    os.chdir(oldcwd)

    return parseOutput(proc.stdout)

def addScore(builds, scores, results, score):
    assert score not in results
    assert score not in scores

    scores.append(score)

    results[score] = dict()
    for build in builds:
        results[score][build] = []

def parseOutput(text):
    result = dict()
    for line in text.splitlines():
        match = re.match(r'(\w+):\s(\d+)', line)
        if match:
            result[match.group(1)] = int(match.group(2))

    if not result:
        print(text)
        sys.exit("Can't parse output")

    return result

def printHeader():
    print((24 * " ") + "Min       Mean      Max       CofV   Runs  Change")
    print(73 * "=")

def displayResults(builds, scores, results, showSamples):
    clearDisplay()

    geomean = dict()
    for build in builds:
        geomean[build] = 0

    firstScore = True
    for score in scores:
        if firstScore:
            firstScore = False

        display(f"{score}:")

        statsForBuild = dict()
        compareTo = None
        low = None
        high = None
        first = True
        for build in builds:
            data = results[score][build]
            if data:
                stats = Stats(data, compareTo)
                statsForBuild[build] = stats
                geomean[build] += math.log(stats.mean)
                if first:
                    compareTo = stats.mean
                    low, high = stats.min, stats.max
                    first = False
                else:
                    low, high = min(low, stats.min), max(high, stats.max)

        for build in builds:
            text = ""
            samples = ""
            if build in statsForBuild:
                stats = statsForBuild[build]
                text = formatResults(stats)

                if low != high and stats.count > 1:
                    text += "   " + formatBox(low, high, stats)
                    if showSamples:
                        samples = formatSamples(low, high, stats)

            display("  %20s  %s" % (build.spec[-20:], text))
            if showSamples:
                display((76 * ' ') + samples)

    count = len(scores)
    if count > 1:
        display()
        display("Geometric mean:")
        compareTo = None
        first = True
        for build in builds:
            if geomean[build] != 0:
                mean = math.exp(geomean[build] / count)
                text = "          %8.1f" % mean
                if first:
                    compareTo = mean
                    first = False
                else:
                    diff = (mean - compareTo) / compareTo
                    text += "                         %4.1f%%" % (diff * 100)
                display("  %20s  %s" % (build.spec[-20:], text))

def formatResults(stats):
    diff = "%4.1f%%" % (stats.diff * 100) if stats.diff else ''
    return "%8.1f  %8.1f  %8.1f  %4.1f%%  %4d  %6s" % (
        stats.min, stats.mean, stats.max, stats.cofv * 100, stats.count, diff)

def formatBox(low, high, stats):
    width = 40
    scale = (high - low) / (width - 1)

    def pos(x):
        assert x >= low
        return int((x - low) // scale)

    devhigh = stats.mean + stats.stdv / 2
    devlow = stats.mean - stats.stdv / 2

    chars = list()
    for i in range(width):
        x = low + i * scale
        if x >= stats.max:
            c = ' '
        elif x >= devhigh:
            c = '-'
        elif x >= devlow:
            c = '='
        elif x >= stats.min:
            c = '-'
        else:
            c = ' '

        chars.append(c)

    chars[pos(stats.min)] = "|"
    chars[pos(stats.max)] = "|"
    chars[pos(stats.mean)] = "O"

    return ''.join(chars)

def formatSamples(low, high, stats):
    width = 40
    scale = (high - low) / (width - 1)

    def pos(x):
        assert x >= low
        return int((x - low) // scale)

    chars = [' '] * width
    for x in stats.samples:
        chars[pos(x)] = 'x' if chars[pos(x)] == ' ' else 'X'

    return ''.join(chars)

def meanstdv(x):
    # from http://www.physics.rutgers.edu/~masud/computing/WPark_recipes_in_python.html
    n, mean, std = len(x), 0, 0
    for a in x:
        mean = mean + a
    mean = mean / float(n)
    for a in x:
        std = std + (a - mean) ** 2
    if n > 1:
        std = math.sqrt(std / float(n - 1))
    else:
        std = 0.0
    return mean, std

try:
    main()
except KeyboardInterrupt:
    pass
